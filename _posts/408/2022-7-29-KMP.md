---
layout: blog
istop: true
title: "KMP"
date:  2017-03-07
category: DS
tags:
- DS
- 408
---

# <center>KMP专题</center>

## Next数组

### 利用部分匹配值（PM）计算（法一）：

部分匹配值：字符前缀和后缀最长相等的前缀后缀长度：

例如字符串:'ababa': 
$$
\begin{aligned}
&'ababa': \\  
&'a':0 (前后缀均为空集) \\
&'ab':前缀：\{a\},后缀：\{b\},相等长度：\{a\} \cap \{ b\}=\emptyset\implies 0  \\
&'aba':前缀：\{a,ab\},后缀：\{ba,a\},相等长度：\{a,ab\}\cap\{ba,a\}=\{a\}  \implies 1\\
&'abab':\{a,ab,aba\}\cap\{b,ab,bab\}=\{ab\}\implies 2\\
&'ababa':\{a,ab,aba,abab\}\cap\{a,ba,aba,baba\}=\{a,aba\}\implies 3\\
\end{aligned}
$$

得PM表：

| 编号 | 1    | 2    | 3    | 4    | 5    |
| ---- | ---- | ---- | ---- | ---- | ---- |
| S    | a    | b    | a    | b    | a    |
| PM   | 0    | 0    | 1    | 2    | 3    |



---

next数组：由PM表右移一位，左边补-1，右边溢出直接舍弃：

| 编号 | 1    | 2    | 3    | 4    | 5    |
| ---- | ---- | ---- | ---- | ---- | ---- |
| S    | a    | b    | a    | b    | a    |
| next | -1   | 0    | 0    | 1    | 2    |

---

next数组整体加1，得：

| 编号 | 1    | 2    | 3    | 4    | 5    |
| ---- | ---- | ---- | ---- | ---- | ---- |
| S    | a    | b    | a    | b    | a    |
| next | 0    | 1    | 1    | 2    | 3    |



### 利用公式计算（法二）：

next函数公式：
$$
next[j]=\begin{cases}
0&\text{当j=1时}\\
\max(k|1<k<j \text{且} p_1p_2\dots p_{k-1}='p_{j-k+1}\dots p_{j-1}') &\text{当此集合不空时} \\
1&\text{其他情况}
\end{cases}
$$
<font color=red>规律：即由1~j-1的串前缀后缀相同个数+ 1</font>

例'abcabx'：

j=6时：j由1~5的串即：'abcab'，其中'ab'='ab'，故next[6]=3

得：

| j       | 1    | 2    | 3    | 4    | 5    | 6    |
| ------- | ---- | ---- | ---- | ---- | ---- | ---- |
| 串T     | a    | b    | c    | a    | b    | x    |
| next[j] | 0    | 1    | 1    | 1    | 2    | 3    |

---

### 算法实现：

#### 计算Next数组的值：

```c++
/*通过计算返回子串T的next数组*/
void get_next(String T,int *next)
{
    int i,j;
    i=1;
    j=0;
    next[1]=0;
   //令next[1]=0,即next[j]={0,当j=1时}（公式第一种情况）
    while(i<T[0]){   //T[0]为串T的长度
        if(j=0||T[i]==T[j])   //若j=0或T[i]=T[j]右移，next[i]=j
        {
            ++i;
            ++j;
            next[i]=j;
        }
        else				//否则，j值回溯，再次比较,直至j=1
        {
            j=next{j};
        }
    }
}
```

#### 算法模拟：

例：T='ababaaa'

| j       | 1    | 2    | 3    | 4    | 5    | 6    | 7    |
| ------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| T       | a    | b    | a    | b    | a    | a    | a    |
| next[j] | 0    | 1    | 1    | 2    | 3    | 4    | 2    |

$$
\begin{aligned}
&\text{起始}：\\
&i=1,j=0,next[1]=0,i<T[0]=7,\text{进入循环} \\
&j=0,true\implies i=2,j=1,next[2]=1\\
&\left.
\begin{matrix}
   i<T[0]\text{进入循环：}j\ &\text{if } b \\
   c &\text{if } d
\end{matrix}
\right \}

\end{aligned}

$$

